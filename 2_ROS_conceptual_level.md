# ROS at a Conceptual Level

Before we learn how to develop robotics applications with ROS, we need to understand the ROS architecture.

## Publisher/Subscriber Model

Probably the most common way of organizing software with ROS is through the [publish-subscribe pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).
In this pattern, _nodes_ will publish and/or subscribe to _messages_ from certain _topics_.

### Nodes

_More information about ROS Nodes can be found [here](https://wiki.ros.org/Nodes)._

A ROS _node_ is basically a process.
A node typically results from running an executable that is created from the code we write.
Nodes usually do one of the following (or both):
1. Process data received from a topic that the node is subscribed to
2. Generate data and share this data by publishing it to a topic

### Topics

_More information about ROS Topics can be found [here](https://wiki.ros.org/Topics)._

A ROS _topic_ can be viewed as a miniature data center.
Topics receive data from one or more nodes and share this data with any nodes that subscribe to this topic.
Topics allow for nodes to function independently of one another.
ROS nodes should work even if:
1. Topics a node subscribes to produce no data
2. Topics a node publishes to have no subscribers

### Messages

_More information about ROS Messages can be found [here](https://wiki.ros.org/Messages)._

A ROS _message_ ia how data is represented when passed to/from nodes.
Instead of using typical [primitive data types](https://en.wikipedia.org/wiki/Primitive_data_type) like `int`, `bool`, or `char` to represent data being passed throughout the ROS network, _message types_ are used.
These message types help encapsulate things like a robot's [pose](http://docs.ros.org/api/geometry_msgs/html/msg/Pose.html), which is too complex to define using a single primitive data type.

For more information on common ROS message types, take a look at the [common_msgs](https://wiki.ros.org/std_msgs) page.
It's important to note that all ROS messages are built on [std_msgs](https://wiki.ros.org/std_msgs), which represent primitive data types.

## Services

_More information about ROS Services can be found [here](https://wiki.ros.org/Services)._

For certain tasks, the [request-response](https://en.wikipedia.org/wiki/Request%E2%80%93response) approach is a better solution than the [publish-subscribe pattern](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern).
Perhaps node A needs to know the state of node B in order to determine what to do next.
ROS _services_ can be used instead of publishers and subscribers in order to achieve request-response behavior.
A ROS _service_ involves a request and response: node A will send a request to node B, and then wait for node B's response.

It's important to note that services are _blocking_, so node A cannot do anything until it has received a response from node B.
Every service has an associated _service type_, which consists of a _request_ and _response_ message type.

## Parameters

_More information about ROS Parameters can be found [here](https://wiki.ros.org/Parameter%20Server)._

ROS _parameters_ are variables can be modified to affect the behavior of a node.
Parameters are stored in a _parameter server_, and nodes use this server to store and retrieve parameters at runtime.

Parameters are a good way to make nodes configurable so that a node's behavior can be changed without having to re-write and recompile code that defines the node.
An example use case of a parameter is the resolution of a map generated by SLAM.

## Master

_More information about the ROS Master can be found [here](https://wiki.ros.org/Master)._

The ROS _master_ is what glues together nodes within a program.
The master provides the parameter server, keeps tracks of which nodes publish and subscribe to which topics, and also manages services.

ROS nodes cannot run if the master is not running, so be sure to always start master first!

## Packages

_More information about ROS Packages can be found [here](https://wiki.ros.org/Packages)._

A ROS _package_ is analogous to a typical software package: it is a collection of source code that can be used to produce things like nodes, messages, or services.
Robotics applications that are built on ROS are typically composed of many different ROS packages.
ROS packages that you create should be [modular](https://en.wikipedia.org/wiki/Modular_programming), which is why you'll often see things like message or services types represented in individual packages.

## Workspaces

A _workspace_ is simply a location on your machine that contains one or more packages.
Workspaces are typically used to represent a project and its dependencies: for example, if you were working on something related to computer vision, you may have a workspace named `vision` with packages for perception and localization.
Workspaces are useful because you can build all of the packages in a workspace at once, which allows for isolation between projects and an easy way to automate software production/testing.

## Catkin

_More information about Catkin can be found [here](https://wiki.ros.org/catkin)._

### Build System vs Build Tool